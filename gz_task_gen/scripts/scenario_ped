#!/usr/bin/env python



from pathlib import Path
import json, six, abc
import rospy, math, time
from geometry_msgs.msg import Pose, PoseWithCovarianceStamped, Point, Quaternion
from threading import Lock
from nav_msgs.msg import OccupancyGrid, Odometry
from nav_msgs.srv import GetMap
from gazebo_msgs.srv import SetModelState, SpawnModel, DeleteModel
from gazebo_msgs.msg import ModelState
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
import actionlib
from std_msgs.msg import Int16
import numpy as np
from tf.transformations import quaternion_from_euler

from Ped_manager.ArenaScenario import *
from std_srvs.srv import Trigger
from pedsim_srvs.srv import SpawnPeds
from pedsim_srvs.srv import SpawnInteractiveObstacles
from pedsim_srvs.srv import SpawnObstacle
from pedsim_msgs.msg import Ped, AgentStates
from pedsim_msgs.msg import InteractiveObstacle
from pedsim_msgs.msg import LineObstacles
from pedsim_msgs.msg import LineObstacle
from rospkg import RosPack


standart_orientation = quaternion_from_euler(0.0,0.0,0.0)
def generate_freespace_indices(map_):
    """generate the indices(represented in a tuple) of the freesapce based on the map
    Returns:
        indices_y_x(tuple): indices of the non-occupied cells, the first element is the y-axis indices,
        the second element is the x-axis indices.
    """
    width_in_cell, height_in_cell = map_.info.width, map_.info.height
    map_2d = np.reshape(map_.data, (height_in_cell, width_in_cell))
    indices_y_x = np.where(map_2d == 0)
    return indices_y_x

# def spawn_peds_in_gazebo():
#     global xml_file

#     def actor_poses_callback(actors):
 
#         for actor in actors.agent_states:
#             actor_id = str( actor.id )
#             memory.append(actor_id)
#             actor_pose = actor.pose
#             rospy.loginfo("Spawning model: actor_id = %s", actor_id)

#             model_pose = Pose(Point(x= actor_pose.position.x,
#                                 y= actor_pose.position.y,
#                                 z= actor_pose.position.z),
#                             Quaternion(actor_pose.orientation.x,
#                                         actor_pose.orientation.y,
#                                         actor_pose.orientation.z,
#                                         actor_pose.orientation.w) )
#             rospy.Subscriber('/gazebo/model_state', GetModelState)
  
#                 spawn_model(actor_id, xml_string, "", model_pose, "world")
#                 memory.append(actor_id)
#         return

#     rospack1 = RosPack()
#     pkg_path = rospack1.get_path('pedsim_gazebo_plugin')
#     default_actor_model_file = pkg_path + "/models/actor_model.sdf"
#     actor_model_file = rospy.get_param('~actor_model_file', default_actor_model_file)
#     file_xml = open(actor_model_file)
#     xml_string = file_xml.read()
#     spawn_model = rospy.ServiceProxy("gazebo/spawn_sdf_model", SpawnModel)
#     rospy.Subscriber("/pedsim_simulator/simulated_agents", AgentStates, actor_poses_callback)


# class ObstaclesManager:
#     """
#     A manager class using flatland provided services to spawn, move and delete obstacles.
#     """

#     def __init__(self, ns, map_):
#         # tpye (str, OccupancyGrid)
#         """
#         Args:
#             map_ (OccupancyGrid):
#             plugin_name: The name of the plugin which is used to control the movement of the obstacles, Currently we use "RandomMove" for training and Tween2 for evaluation.
#                 The Plugin Tween2 can move the the obstacle along a trajectory which can be assigned by multiple waypoints with a constant velocity.Defaults to "RandomMove".
#         """
#         self.ns = ns
#         self.ns_prefix = "" if ns == '' else "/"+ns+"/"

#         # a list of publisher to move the obstacle to the start pos.
#         self._move_all_obstacles_start_pos_pubs = []

#         rospy.wait_for_service(f'{self.ns_prefix}SpawnModel', timeout=20)
#         rospy.wait_for_service(f'{self.ns_prefix}DeleteModel', timeout=20)
#         # allow for persistent connections to services
#         self._srv_move_model = rospy.ServiceProxy(
#             self.ns_prefix,'move_model', MoveModel, persistent=True) # persistent connection insted of reconecting each time
#         self._srv_delete_model = rospy.ServiceProxy(
#             self.ns_prefix, 'delete_model', DeleteModel, persistent=True)
#         self._srv_spawn_model = rospy.ServiceProxy(
#             self.ns_prefix, 'spawn_model', SpawnModel, persistent=True)

#         self.update_map(map_)
#         self.obstacle_name_list = []
#         self._obstacle_name_prefix = 'obstacle'
#         # remove all existing obstacles generated before create an instance of this class
#         self.remove_obstacles()


    # def update_map(self, new_map):
    #     # type (OccupancyGrid)-> None
    #     self.map = new_map
    #     # a tuple stores the indices of the non-occupied spaces. format ((y,....),(x,...)
    #     self._free_space_indices = generate_freespace_indices(self.map)

    # def remove_obstacle(self, name):
    #     # type (str) -> None
    #     if len(self.obstacle_name_list) != 0:
    #         assert name in self.obstacle_name_list
    #     #srv_request = DeleteModelRequest()
    #     #srv_request.name = name
    #     response = self._srv_delete_model(srv_request)

    #     if not response.success:
    #         """
    #         raise rospy.ServiceException(
    #             f"failed to remove the object with the name: {name}! ")
    #         """
    #         warnings.warn(
    #             f"failed to remove the object with the name: {name}!")
    #     else:
    #         rospy.logdebug(f"Removed the obstacle with the name {name}")


class RobotManager:
    """
    A manager class using flatland provided services to spawn, move and delete Robot. Currently only one robot
    is managed
    """

    def __init__(self, ns, map_):
        # type (str, OccupancyGrid, str, int) -> None
        """[summary]
        Args:
            ns(namespace): if ns == '', we will use global namespace
            map_ (OccupancyGrid): the map info
            robot_yaml_path (str): the file name of the robot yaml file.
        """
        self.ns = ns
        self.update_map(map_)


    def update_map(self, new_map):
        # type (OccupancyGrid) -> None
        self.map = new_map
        self._free_space_indices = generate_freespace_indices(self.map)



    def move_robot(self, pose):
        # type: (Pose) -> None
        """move the robot to a given position
        Args:
            pose (Pose): target postion
        """

        start_pos = ModelState()
        start_pos.model_name = 'turtlebot3'
        start_pos.pose = pose

        rospy.wait_for_service('/gazebo/set_model_state')
        try:
            set_state = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)
            resp = set_state(start_pos)

        except rospy.ServiceException:
            print("Move Robot to position failed")

        pub = rospy.Publisher('/initialpose', PoseWithCovarianceStamped, queue_size = 10)
        rospy.sleep(3)
        start_pos = PoseWithCovarianceStamped()
        start_pos.header.frame_id = 'map'
        start_pos.pose.pose = pose # Achtung in Random task hier .pose.pose
        pub.publish(start_pos)



    def publish_goal(self, pose):
        # type: (Pose) -> None
        """
        Publishing goal (x, y, theta)
        :param x x-position of the goal
        :param y y-position of the goal
        :param theta theta-position of the goal
        """

        client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
        client.wait_for_server()

        self.goal = MoveBaseGoal()
        self.goal.target_pose.header.frame_id = "map"
        self.goal.target_pose.header.stamp = rospy.Time.now()
        self.goal.target_pose.pose = pose

        client.send_goal(self.goal)
        wait = client.wait_for_result()
        if not wait: ############################################can be deleted later
            rospy.logerr("Action server not available!")
            rospy.signal_shutdown("Action server not available!")



    def set_start_pos_goal_pos(self, start_pos = None, goal_pos = None, min_dist=1):
        # type: (Union[Pose2D, None], Union[Pose2D, None], int)
        """set up start position and the goal postion. Path validation checking will be conducted. If it failed, an
        exception will be raised.
        Args:
            start_pos (Union[Pose2D,None], optional): start position. if None, it will be set randomly. Defaults to None.
            goal_pos (Union[Pose2D,None], optional): [description]. if None, it will be set randomly .Defaults to None.
            min_dist (float): minimum distance between start_pos and goal_pos
        Exception:
            Exception("can not generate a path with the given start position and the goal position of the robot")
        """

        def dist(x1, y1, x2, y2):
            return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

        if start_pos is None or goal_pos is None:
            # if any of them need to be random generated, we set a higher threshold,otherwise only try once
            max_try_times = 20
        else:
            max_try_times = 1

        i_try = 0
        start_pos_ = None
        goal_pos_ = None
        while i_try < max_try_times:
            start_pos_ = start_pos
            goal_pos_ = goal_pos
            if dist(start_pos_.position.x, start_pos_.position.y, goal_pos_.position.x, goal_pos_.position.y) < min_dist:
                i_try += 1
                continue
            # move the robot to the start pos
            self.move_robot(start_pos_)
            try:
                # publish the goal, if the gobal plath planner can't generate a path, a, exception will be raised.
                self.publish_goal(goal_pos_)
                break
            except rospy.ServiceException:
                i_try += 1
        if i_try == max_try_times:
            # TODO Define specific type of Exception
            raise rospy.ServiceException(
                "can not generate a path with the given start position and the goal position of the robot")
        else:
            return start_pos_, goal_pos_

@six.add_metaclass(abc.ABCMeta)
class ABSTask(abc.ABCMeta('ABC', (object,), {'__slots__': ()})):
    """An abstract class, all tasks must implement reset function.
    """

    def __init__(self, robot_manager):
        # type: (ObstaclesManager, RobotManager) -> None
        #self.obstacles_manager = obstacles_manager
        self.robot_manager = robot_manager
        self._service_client_get_map = rospy.ServiceProxy('/static_map', GetMap)
        self._map_lock = Lock()
        rospy.Subscriber('/map', OccupancyGrid, self._update_map)
        # a mutex keep the map is not unchanged during reset task.

    @abc.abstractmethod #abstract methods must be implemented in its sub-classes
    def reset(self):
        """
        a funciton to reset the task. Make sure that _map_lock is used.
        """

    def _update_map(self, map_):
        # type (OccupancyGrid) -> None
        with self._map_lock:
            #self.obstacles_manager.update_map(map_)
            self.robot_manager.update_map(map_)


class PedsimManager():
    def __init__(self):
        # spawn peds
        spawn_peds_service_name = "pedsim_simulator/spawn_peds"
        rospy.wait_for_service(spawn_peds_service_name, 6.0)
        self.spawn_peds_client = rospy.ServiceProxy(spawn_peds_service_name, SpawnPeds)
        # respawn peds
        respawn_peds_service_name = "pedsim_simulator/respawn_peds"
        rospy.wait_for_service(respawn_peds_service_name, 6.0)
        self.respawn_peds_client = rospy.ServiceProxy(respawn_peds_service_name, SpawnPeds)
        # spawn interactive obstacles
        pawn_interactive_obstacles_service_name = "pedsim_simulator/spawn_interactive_obstacles"
        rospy.wait_for_service(pawn_interactive_obstacles_service_name, 6.0)
        self.spawn_interactive_obstacles_client = rospy.ServiceProxy(pawn_interactive_obstacles_service_name, SpawnInteractiveObstacles)
        # respawn interactive obstacles
        respawn_interactive_obstacles_service_name = "pedsim_simulator/respawn_interactive_obstacles"
        rospy.wait_for_service(respawn_interactive_obstacles_service_name, 6.0)
        self.respawn_interactive_obstacles_client = rospy.ServiceProxy(respawn_interactive_obstacles_service_name, SpawnInteractiveObstacles)
        # respawn interactive obstacles
        reset_all_peds_service_name = "pedsim_simulator/reset_all_peds"
        rospy.wait_for_service(reset_all_peds_service_name, 6.0)
        self.reset_all_peds_client = rospy.ServiceProxy(reset_all_peds_service_name, Trigger)

    def spawnPeds(self, peds):
        # type (List[Ped])
        res = self.spawn_peds_client.call(peds)
        print(res)

    def respawnPeds(self, peds):
        # type (List[Ped])
        res = self.respawn_peds_client.call(peds)
        print(res)

    def spawnInteractiveObstacles(self, obstacles):
        # type (List[InteractiveObstacle])
        res = self.spawn_interactive_obstacles_client.call(obstacles)
        print(res)

    def respawnInteractiveObstacles(self, obstacles):
        # type (List[InteractiveObstacle])
        res = self.respawn_interactive_obstacles_client.call(obstacles)
        print(res)

    def resetAllPeds(self):
        res = self.reset_all_peds_client.call()
        print(res)

class ScenarioTask(ABSTask):
    def __init__(self, robot_manager, scenario_path='/home/elias/catkin_ws/src/arena-rosnav-3D/simulator_setup/scenarios/test_scenario.json'):
        # type: (ObstaclesManager, RobotManager, str) -> Any
        super(ScenarioTask, self).__init__(robot_manager)

        # load scenario from file
        self.scenario = ArenaScenario()
        self.scenario.loadFromFile(scenario_path)

        # setup pedsim agents
        self.pedsim_manager = None
        if len(self.scenario.pedsimAgents) > 0:
            self.pedsim_manager = PedsimManager()
            peds = [agent.getPedMsg() for agent in self.scenario.pedsimAgents]
            self.pedsim_manager.spawnPeds(peds)

        #spawn_peds_in_gazebo()

        self.reset_count = 0

    def reset(self):
        self.reset_count += 1
        info = {}
        with self._map_lock:
            # reset pedsim agents
            if self.pedsim_manager != None:
                self.pedsim_manager.resetAllPeds()

            # reset robot
            self.robot_manager.set_start_pos_goal_pos(
                Pose(Point(*np.append(self.scenario.robotPosition, 0)), Quaternion(*standart_orientation)), 
                Pose(Point(*np.append(self.scenario.robotGoal, 0)), Quaternion(*standart_orientation))
                )

            # fill info dict
            if self.reset_count == 1:
                info["new_scenerio_loaded"] = True
            else:
                info["new_scenerio_loaded"] = False
            info["robot_goal_pos"] = self.scenario.robotGoal
            info['num_repeats_curr_scene'] = self.reset_count
            info['max_repeats_curr_scene'] = 1000  # todo: implement max number of repeats for scenario
        return info

def get_scenario_file_format(path):
    # type: (str) -> None
    path_ = Path(path)
    assert path_.is_file()
    data = json.load(path_.open())
    if "format" in data:
        if data["format"] == "arena-tools":
            return "arena-tools"
    else:
        print('Error: ScenarioFile is not in the right format')
        #return "scenerio"


def get_predefined_task(ns = '', mode="random", start_stage = 1, PATHS = None):
    # type: (str, int, dict, str) -> Any
    service_client_get_map = rospy.ServiceProxy('/static_map', GetMap)
    map_response = service_client_get_map()
    robot_manager = RobotManager(ns='',map_= map_response.map)
    task = ScenarioTask(robot_manager)
    return task


class TaskGenerator:
    def __init__(self):
        #
        self.sr = rospy.Publisher('/scenario_reset', Int16, queue_size=1)
        self.nr = 0
       # mode = rospy.get_param("~task_mode")
  
        self.task = get_predefined_task()

        self.start_time_= time.time()           
        
        self.curr_goal_pos_ = None
        
        auto_reset = False
        
        if auto_reset:
            rospy.loginfo(
                "Task Generator is set to auto_reset mode, Task will be automatically reset as the robot approaching the goal_pos")
            self.reset_task()
            #self.robot_pos_sub_ = rospy.Subscriber(
             #   robot_odom_topic_name, Odometry, self.check_robot_pos_callback)

            rospy.Timer(rospy.Duration(0.5),self.goal_reached)
            
        else:
            # declare new service task_generator, request are handled in callback task generate
            self.reset_task()
                
        self.err_g = 100
        


    def goal_reached(self,event):

        if self.err_g < self.delta_:
            print(self.err_g)
            self.reset_task()
        if(time.time()-self.start_time_>self.timeout_):
            print("timeout")
            self.reset_task()

    def reset_srv_callback(self, req):
        rospy.loginfo("Task Generator received task-reset request!")
        self.task.reset()
        #return EmptyResponse()


    def reset_task(self):
        self.start_time_=time.time()
        info = self.task.reset()
        
        # clear_costmaps()
        if info is not None:
            self.curr_goal_pos_ = info['robot_goal_pos']
        self.sr.publish(self.nr)
        self.nr += 1

    def check_robot_pos_callback(self, odom_msg):
        # type: (Odometry) -> Any
        robot_pos = odom_msg.pose.pose.position
        robot_x = robot_pos.x
        robot_y = robot_pos.y
        goal_x = self.curr_goal_pos_[0]
        goal_y = self.curr_goal_pos_[1]

        self.err_g = (robot_x-goal_x)**2+(robot_y-goal_y)**2
           

if __name__ == '__main__':
    rospy.init_node('scenario')
    task_generator = TaskGenerator()
    rospy.spin()

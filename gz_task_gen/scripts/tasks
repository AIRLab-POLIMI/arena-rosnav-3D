#!/usr/bin/env python


from pathlib import Path
import json, six, abc
import rospy, math, time
from geometry_msgs.msg import Pose, PoseWithCovarianceStamped, Point, Quaternion
from threading import Lock
from nav_msgs.msg import OccupancyGrid, Odometry
from nav_msgs.srv import GetMap
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.msg import ModelState
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
import actionlib
from std_msgs.msg import Int16
import numpy as np
from tf.transformations import quaternion_from_euler


@six.add_metaclass(abc.ABCMeta)
class ABSTask(abc.ABCMeta('ABC', (object,), {'__slots__': ()})):
    """An abstract class, all tasks must implement reset function.
    """

    def __init__(self, robot_manager):
        # type: (ObstaclesManager, RobotManager) -> None
        #self.obstacles_manager = obstacles_manager
        self.robot_manager = robot_manager
        self._service_client_get_map = rospy.ServiceProxy('/static_map', GetMap)
        self._map_lock = Lock()
        rospy.Subscriber('/map', OccupancyGrid, self._update_map)
        # a mutex keep the map is not unchanged during reset task.

    @abc.abstractmethod #abstract methods must be implemented in its sub-classes
    def reset(self):
        """
        a funciton to reset the task. Make sure that _map_lock is used.
        """

    def _update_map(self, map_):
        # type (OccupancyGrid) -> None
        with self._map_lock:
            #self.obstacles_manager.update_map(map_)
            self.robot_manager.update_map(map_)

            
class ScenerioTask(ABSTask):
    def __init__(self, robot_manager, scenerios_json_path='/home/elias/catkin_ws/src/simulator_setup/scenarios/only_robot.json'):
        # type: (RobotManager, str) -> None
        """ The scenerio_json_path only has the "Scenerios" section, which contains a list of scenerios
        Args:
            scenerios_json_path (str): [description]
        """
        super(ScenerioTask, self).__init__(robot_manager)
        
        json_path = Path(scenerios_json_path)
        
        assert json_path.is_file() and json_path.suffix == ".json"
        json_data = json.load(json_path.open())
        
        self._scenerios_data = json_data["scenarios"]
        # current index of the scenerio
        self._idx_curr_scene = -1
        # The times of current scenerio repeated
        self._num_repeats_curr_scene = -1
        # The times of current scenerio need to be repeated
        self._max_repeats_curr_scene = 0

    def reset(self):
        info = {}
        with self._map_lock:
            if self._idx_curr_scene == -1 or self._num_repeats_curr_scene == self._max_repeats_curr_scene:
                self._set_new_scenerio()
                info["new_scenerio_loaded"] = True
            else:
                info["new_scenerio_loaded"] = False
            # reset robot
            robot_data = self._scenerios_data[self._idx_curr_scene]['robot']
            robot_start_pos = robot_data["start_pos"]
            robot_goal_pos = robot_data["goal_pos"]
            info["robot_goal_pos"] = robot_goal_pos
            self.robot_manager.set_start_pos_goal_pos(
                Pose(Point(*robot_start_pos), Quaternion(*standart_orientation)), Pose(Point(*robot_goal_pos), Quaternion(*standart_orientation)))
            self._num_repeats_curr_scene += 1
            info['num_repeats_curr_scene'] = self._num_repeats_curr_scene
            info['max_repeats_curr_scene'] = self._max_repeats_curr_scene
        return info

    def _set_new_scenerio(self):
        try:
            while True:
                self._idx_curr_scene += 1
                scenerio_data = self._scenerios_data[self._idx_curr_scene]
                scenerio_name = scenerio_data['scene_name']
                print("======================================================")
                print("Scenario ", scenerio_name," loaded")
                print("======================================================")
                # use can set "repeats" to a non-positive value to disable the scenerio
                if scenerio_data["repeats"] > 0:
                    # self.robot_
                    robot_data = scenerio_data["robot"]
                    robot_start_pos = robot_data["start_pos"]
                    robot_goal_pos = robot_data["goal_pos"]
                    self.robot_manager.set_start_pos_goal_pos(
                        Pose(Point(*robot_start_pos), Quaternion(*standart_orientation)), Pose(Point(*robot_goal_pos), Quaternion(*standart_orientation)))
                    
                    self._num_repeats_curr_scene = 0
                    self._max_repeats_curr_scene = scenerio_data["repeats"]
                    break
        except IndexError:
            print('All scenerios have been evaluated!r')
            #raise StopReset("All scenerios have been evaluated!")

    @staticmethod
    def generate_scenerios_json_example(dst_json_path):
        # type (str)
        dst_json_path_ = Path(dst_json_path)
        dst_json_path_.parent.mkdir(parents=True, exist_ok=True)
        json_data = {}
        scene1 = {}
        scene2 = {}
        scene1['scene_name'] = 'scene_1'
        scene1['repeats'] = 2
        scene1_robot = {'start_pos': [
            0.0, 0.0, 0.2], 'goal_pos': [4, 8, 0]}
        # trigger is optional, if it is not given, it will be trigged immediately
        scene1['robot'] = scene1_robot
        scene2['scene_name'] = 'scene_2'
        scene2['repeats'] = 1
        scene2_robot = {'start_pos': [
            0.0, 0.1, 0.2], 'goal_pos': [1.5, 1.5, 0]}
        scene2['robot'] = scene2_robot
        json_data['scenerios'] = [scene1, scene2]
        json.dump(json_data, dst_json_path_.open('w'), indent=4)

def get_predefined_task(ns = '', mode="random", start_stage = 1, PATHS = None):
    # type (str, int, dict) -> task
    service_client_get_map = rospy.ServiceProxy('/static_map', GetMap)
    map_response = service_client_get_map()
    robot_manager = RobotManager(ns='',map_= map_response.map)
    task = ScenerioTask(robot_manager)
    return task
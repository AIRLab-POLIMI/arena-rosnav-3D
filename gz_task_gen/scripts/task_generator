#!/usr/bin/env python


import rospy, math, actionlib, time, os
import json, yaml, tf, threading
import numpy as np
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from geometry_msgs.msg import Pose, Point, Quaternion, PoseStamped, Pose2D
from std_srvs.srv import EmptyResponse
from nav_msgs.msg import Odometry, OccupancyGrid, Path
from std_msgs.msg import Int16, Bool
#from abc import ABC, abstractmethod
from threading import Condition, Lock
from filelock import FileLock
from nav_msgs.srv import GetMap
from pathlib import Path
from typing import Union
from gazebo_msgs.srv import SpawnModel


#def get_random_pos_on_map(free_space_indices, map_: OccupancyGrid, safe_dist: float, forbidden_zones: list = None):
def get_random_pos_on_map(free_space_indices, map_, safe_dist, forbidden_zones = None):
    """
    Args:
        indices_y_x(tuple): a 2 elementary tuple stores the indices of the non-occupied cells, the first element is the y-axis indices,
            the second element is the x-axis indices.
        map (OccupancyGrid): map proviced by the ros map service
        forbidden_zones (list of 3 elementary tuple(x,y,r)): a list of zones which is forbidden
    Returns:
       x_in_meters,y_in_meters,theta
    """

    def is_pos_valid(x_in_meters, y_in_meters):
        for forbidden_zone in forbidden_zones:
            if (x_in_meters-forbidden_zone[0])**2+(y_in_meters-forbidden_zone[1])**2 < (forbidden_zone[2]+safe_dist)**2:
                return False

        # in pixel
        cell_radius = int(safe_dist / map_.info.resolution)
        x_index = int((x_in_meters - map_.info.origin.position.x) // map_.info.resolution)
        y_index = int((y_in_meters - map_.info.origin.position.y) // map_.info.resolution)

        # check occupancy around (x_index,y_index) with cell_radius
        # TODO use numpy for checking
        for i in range(x_index - cell_radius, x_index + cell_radius, 1):
            for j in range(y_index - cell_radius, y_index + cell_radius, 1):
                index = j * map_.info.width + i
                if index >= len(map_.data):
                    return False
                try:
                    value = map_.data[index]
                except IndexError:
                    print("IndexError: index: %d, map_length: %d" %
                          (index, len(map_.data)))
                    return False
                if value != 0:

                    return False
        return True

    assert len(free_space_indices) == 2 and len(free_space_indices[0]) == len(
        free_space_indices[1]), "free_space_indices is not correctly setup"
    if forbidden_zones is None:
        forbidden_zones = []

    n_freespace_cells = len(free_space_indices[0])
    pos_valid = False
    n_check_failed = 0
    x_in_meters, y_in_meters = None, None
    while not pos_valid:
        idx = random.randint(0, n_freespace_cells-1)
        # in cells
        y_in_cells, x_in_cells = free_space_indices[0][idx], free_space_indices[1][idx]
        # convert x, y in meters
        y_in_meters = y_in_cells * map_.info.resolution + map_.info.origin.position.y
        x_in_meters = x_in_cells * map_.info.resolution + map_.info.origin.position.x
        pos_valid = is_pos_valid(x_in_meters, y_in_meters)
        if not pos_valid:
            n_check_failed += 1
            if n_check_failed > 100:
                raise Exception(
                    "cann't find any no-occupied space please check the map information")
        # in radius
    theta = random.uniform(-math.pi, math.pi)

    return x_in_meters, y_in_meters, theta

#def generate_freespace_indices(map_: OccupancyGrid) -> tuple:
def generate_freespace_indices(map_):
    """generate the indices(represented in a tuple) of the freesapce based on the map
    Returns:
        indices_y_x(tuple): indices of the non-occupied cells, the first element is the y-axis indices,
        the second element is the x-axis indices.
    """
    width_in_cell, height_in_cell = map_.info.width, map_.info.height
    map_2d = np.reshape(map_.data, (height_in_cell, width_in_cell))
    indices_y_x = np.where(map_2d == 0)
    return indices_y_x


class RobotManager:
    """
    A manager class using flatland provided services to spawn, move and delete Robot. Currently only one robot
    is managed
    """

    #def __init__(self, ns: str, map_: OccupancyGrid, robot_yaml_path: str, timeout=20):
    def __init__(self, ns, map_, robot_yaml_path, timeout=20):
        """[summary]
        Args:
            ns(namespace): if ns == '', we will use global namespace
            map_ (OccupancyGrid): the map info
            robot_yaml_path (str): the file name of the robot yaml file.
        """
        self.ns = ns
        self.ns_prefix = "" if ns == "" else "/"+ns+"/"

        self._get_robot_configration(robot_yaml_path)###########################################################
        #setup proxy to handle  services provided by flatland
       # rospy.wait_for_service(f'{self.ns_prefix}move_model', timeout=timeout)
       # rospy.wait_for_service(f'{self.ns_prefix}spawn_model', timeout=timeout)
        #rospy.wait_for_service('step_world', timeout=20)
        # self._srv_move_model = rospy.ServiceProxy(
        #     f'{self.ns_prefix}move_model', MoveModel)
        # self._srv_spawn_model = rospy.ServiceProxy(
        #     f'{self.ns_prefix}spawn_model', SpawnModel)
        # # it's only needed in training mode to send the clock signal.
        # self._step_world = rospy.ServiceProxy(
        #     f'{self.ns_prefix}step_world', StepWorld) ############################################################

        # publisher
        #self._goal_pub = rospy.Publisher(f'{self.ns_prefix}goal', PoseStamped, queue_size=1, latch=True)

        self.update_map(map_)
       # self._spawn_robot(robot_yaml_path)

        # path generated by the  global planner
        self._global_path = Path()
        # the timestamp will be used for checking whether the global planner can find a valid path
        # between new start position and new goal
        self._old_global_path_timestamp = None
        self._new_global_path_generated = False
        # a condition variable used for
        self._global_path_con = threading.Condition()
        self._static_obstacle_name_list = []

    #def _spawn_robot(self, robot_yaml_path: str):
    # def _spawn_robot(self, robot_yaml_path):
    #     request = SpawnModelRequest()
    #     request.yaml_path = robot_yaml_path
    #     request.name = "myrobot"
    #     request.ns = self.ns
    #     self._srv_spawn_model(request)

    def _get_robot_configration(self, robot_yaml_path):
        """get robot info e.g robot name, radius, Laser related infomation
        Args:
            robot_yaml_path ([type]): [description]
        """
        self.ROBOT_NAME = os.path.basename(robot_yaml_path).split('.')[0]
        # with open(robot_yaml_path, 'r') as f:
        #     robot_data = yaml.safe_load(f)
        #     # get robot radius
        #     for body in robot_data['bodies']:
        #         if body['name'] == "base_footprint":
        #             for footprint in body['footprints']:
        #                 if footprint['type'] == 'circle':
        #                     self.ROBOT_RADIUS = footprint.setdefault(
        #                         'radius', 0.2)
        #     # get laser_update_rate
        #     for plugin in robot_data['plugins']:
        #         if plugin['type'] == 'Laser':
        #             self.LASER_UPDATE_RATE = plugin.setdefault(
        #                 'update_rate', 1)

    #def update_map(self, new_map: OccupancyGrid):
    def update_map(self, new_map):
        self.map = new_map
        # a tuple stores the indices of the non-occupied spaces. format ((y,....),(x,...)
        self._free_space_indices = generate_freespace_indices(self.map)

    #def move_robot(self, pose: Pose2D):
    def move_robot(self, pose):
        """move the robot to a given position
        Args:
            pose (Pose2D): target postion
        """
        # call service move_model

        srv_request = MoveModelRequest()
        srv_request.name = self.ROBOT_NAME
        srv_request.pose = pose

        # call service
        self._srv_move_model(srv_request)


    def set_start_pos_random(self):
        start_pos = Pose2D()
        start_pos.x, start_pos, start_pos.theta = get_random_pos_on_map(
            self._free_space_indices, self.map, self.ROBOT_RADIUS)
        self.move_robot(start_pos)

    #def set_start_pos_goal_pos(self, start_pos: Union[Pose2D, None]
    #                           = None, goal_pos: Union[Pose2D, None] = None, min_dist=1):
    
    def set_start_pos_goal_pos(self, start_pos = None, goal_pos = None, min_dist=1):
        """set up start position and the goal postion. Path validation checking will be conducted. If it failed, an
        exception will be raised.
        Args:
            start_pos (Union[Pose2D,None], optional): start position. if None, it will be set randomly. Defaults to None.
            goal_pos (Union[Pose2D,None], optional): [description]. if None, it will be set randomly .Defaults to None.
            min_dist (float): minimum distance between start_pos and goal_pos
        Exception:
            Exception("can not generate a path with the given start position and the goal position of the robot")
        """

        def dist(x1, y1, x2, y2):
            return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

        if start_pos is None or goal_pos is None:
            # if any of them need to be random generated, we set a higher threshold,otherwise only try once
            max_try_times = 20
        else:
            max_try_times = 1

        i_try = 0
        start_pos_ = None
        goal_pos_ = None
        while i_try < max_try_times:

            if start_pos is None:
                start_pos_ = Pose2D()
                start_pos_.x, start_pos_.y, start_pos_.theta = get_random_pos_on_map(
                    self._free_space_indices, self.map, self.ROBOT_RADIUS * 2)
            else:
                start_pos_ = start_pos
            if goal_pos is None:
                goal_pos_ = Pose2D()
                goal_pos_.x, goal_pos_.y, goal_pos_.theta = get_random_pos_on_map(
                    self._free_space_indices, self.map, self.ROBOT_RADIUS * 2)
            else:
                goal_pos_ = goal_pos

            if dist(start_pos_.x, start_pos_.y, goal_pos_.x, goal_pos_.y) < min_dist:
                i_try += 1
                continue
            # move the robot to the start pos
            self.move_robot(start_pos_)
            try:
                # publish the goal, if the gobal plath planner can't generate a path, a, exception will be raised.
                self.publish_goal(goal_pos_.x, goal_pos_.y, goal_pos_.theta)
                break
            except rospy.ServiceException:
                i_try += 1
        if i_try == max_try_times:
            # TODO Define specific type of Exception
            raise rospy.ServiceException(
                "can not generate a path with the given start position and the goal position of the robot")
        else:
            return start_pos_, goal_pos_

    def _validate_path(self):
        """ after publish the goal, the global planner should publish path. If it's not published within 0.1s, an exception will
        be raised.
        Raises:
            Exception: [description]
        """

        with self._global_path_con:
            self._global_path_con.wait_for(
                predicate=self._new_global_path_generated, timeout=0.1)
            if not self._new_global_path_generated:
                raise rospy.ServiceException(
                    "can not generate a path with the given start position and the goal position of the robot")
            else:
                self._new_global_path_generated = False  # reset it

    def publish_goal(self, x, y, theta):
        """
        Publishing goal (x, y, theta)
        :param x x-position of the goal
        :param y y-position of the goal
        :param theta theta-position of the goal
        """
        self._old_global_path_timestamp = self._global_path.header.stamp
        goal = PoseStamped()
        goal.header.stamp = rospy.get_rostime()
        goal.header.frame_id = "map"
        goal.pose.position.x = x
        goal.pose.position.y = y
        quaternion = tf.transformations.quaternion_from_euler(0, 0, 0)
        goal.pose.orientation.w = quaternion[0]
        goal.pose.orientation.x = quaternion[1]
        goal.pose.orientation.y = quaternion[2]
        goal.pose.orientation.z = quaternion[3]
        self._goal_pub.publish(goal)
        # self._validate_path()

    #def _global_path_callback(self, global_path: Path):
    def _global_path_callback(self, global_path):
        with self._global_path_con:
            self._global_path = global_path
            if self._old_global_path_timestamp is None or global_path.header.stamp > self._old_global_path_timestamp:
                self._new_global_path_generated = True
            self._global_path_con.notify()


#class ABSTask(ABC):
class ABSTask():
    """An abstract class, all tasks must implement reset function.
    """

    #def __init__(self, robot_manager: RobotManager):
    def __init__(self, robot_manager):
        self.robot_manager = robot_manager
        self._service_client_get_map = rospy.ServiceProxy('/static_map', GetMap)
        self._map_lock = Lock()
        rospy.Subscriber('/map', OccupancyGrid, self._update_map)
        # a mutex keep the map is not unchanged during reset task.

   # @abstractmethod
    def reset(self):
        """
        a funciton to reset the task. Make sure that _map_lock is used.
        """

   # def _update_map(self, map_: OccupancyGrid):
    def _update_map(self, map_):
        with self._map_lock:
            self.robot_manager.update_map(map_)

class ManualTask(ABSTask):
    """randomly spawn obstacles and user can mannually set the goal postion of the robot
    """

    #def __init__(self, robot_manager: RobotManager):
    def __init__(self, robot_manager):
        #super().__init__(robot_manager)
        # subscribe
       # rospy.Subscriber(f'{self.ns}manual_goal', Pose2D, self._set_goal_callback)
        self._goal = Pose2D()
        self._new_goal_received = False
        self._manual_goal_con = Condition()

    def reset(self):
        while True:
            with self._map_lock:
                self.robot_manager.set_start_pos_random()
                with self._manual_goal_con:
                    # the user has 60s to set the goal, otherwise all objects will be reset.
                    self._manual_goal_con.wait_for(
                        self._new_goal_received, timeout=60)
                    if not self._new_goal_received:
                        raise Exception(
                            "TimeOut, User does't provide goal position!")
                    else:
                        self._new_goal_received = False
                    try:
                        # in this step, the validation of the path will be checked
                        self.robot_manager.publish_goal(
                            self._goal.x, self._goal.y, self._goal.theta)
                    except Exception as e:
                        rospy.logwarn(repr(e))

    #def _set_goal_callback(self, goal: Pose2D):
    def _set_goal_callback(self, goal):
        with self._manual_goal_con:
            self._goal = goal
            self._new_goal_received = True
        self._manual_goal_con.notify()

def get_predefined_task(ns, mode="manual", start_stage = 1):
#def get_predefined_task(ns: str, mode="manual", start_stage: int = 1):
    
    service_client_get_map = rospy.ServiceProxy('/static_map', GetMap) 
    map_response = service_client_get_map()

    # use rospkg to get the path where the model config yaml file stored
    #models_folder_path = rospkg.RosPack().get_path('simulator_setup') #$(find simulator_setup)/maps/$(arg map_file)/map.yaml"#################################
    models_folder_path = '/home/elias/catkin_ws/src/gz_arena_bringup/config/map.yaml'

    # robot's yaml file is needed to get its radius.
    robot_manager = RobotManager(ns, map_response.map, os.path.join(
        models_folder_path, 'robot', "myrobot.model.yaml"))###############################################################
    
    task = None
    if True:
        rospy.set_param("/task_mode", "manual")################################################################################
        task = ManualTask(robot_manager)
        print("manual tasks requested")
    return task


class TaskGenerator:
    def __init__(self):
        self.curr_goal_pos_ = None
        self.task = get_predefined_task("")   
        self.reset_task()
  
    def reset_task(self):
        self.start_time_=time.time()
        info = self.task.reset()
        
        # clear_costmaps()
        if info is not None:
            self.curr_goal_pos_ = info['robot_goal_pos']
        rospy.loginfo("".join(["="]*80))
        rospy.loginfo("goal reached and task reset!")
        rospy.loginfo("".join(["="]*80))
        self.sr.publish(self.nr)
        self.nr += 1

if __name__ == '__main__':
    rospy.init_node('task_generator')
    task_generator = TaskGenerator()
    rospy.spin()
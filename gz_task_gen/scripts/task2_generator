#!/usr/bin/env python


import rospy
import math

import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from geometry_msgs.msg import Pose, Point, Quaternion, PoseWithCovarianceStamped
from tf.transformations import quaternion_from_euler
from gazebo_msgs.srv import SpawnModel, SetModelState
from gazebo_msgs.msg import ModelState 


#class MoveBaseSeq():
class RandomTask:
    def __init__(self):
        
        rospy.init_node('task2_generator')
        spawn_model_client = rospy.ServiceProxy('/gazebo/spawn_sdf_model', SpawnModel)
        start_pos = ModelState()
        start_pos.model_name = 'turtlebot3'
        start_pos.pose.position.x = 3
        start_pos.pose.position.y = 3
        start_pos.pose.position.z = 0
        start_pos.pose.orientation.x = 0
        start_pos.pose.orientation.y = 0
        start_pos.pose.orientation.z = 0
        start_pos.pose.orientation.w = 0


        rospy.wait_for_service('/gazebo/set_model_state')
        try:
            set_state = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)
            resp = set_state( start_pos )

        except rospy.ServiceException, e:
            print "Service call failed: %s" % e
        


        pub = rospy.Publisher('/initialpose', PoseWithCovarianceStamped, queue_size = 10)
       # rospy.sleep(3)
        start_pos = PoseWithCovarianceStamped()

        start_pos.pose.pose.position.x = 3.0
        start_pos.pose.pose.position.y = 3.0
        start_pos.pose.pose.position.z = 0.0

        [x,y,z,w]=quaternion_from_euler(0.0,0.0,0.0)
        start_pos.pose.pose.orientation.x = x
        start_pos.pose.pose.orientation.y = y
        start_pos.pose.pose.orientation.z = z
        start_pos.pose.pose.orientation.w = w

        print start_pos
        pub.publish(start_pos)

        
        #*************************Nav-Goal*********************************************************
        # goal = MoveBaseGoal()
        # goal.target_pose.header.frame_id = "map"
        # goal.target_pose.header.stamp = rospy.Time.now()
        # goal.target_pose.pose.position.x = 0.5
        # goal.target_pose.pose.orientation.w = 1.0

        # client.send_goal(goal)
        # wait = client.wait_for_result()
        # if not wait:
        #     rospy.logerr("Action server not available!")
        #     rospy.signal_shutdown("Action server not available!")
        # else:
        #     return client.get_result()


def get_predefined_task(ns, mode="manual", start_stage = 1):
    
    task = None
    if True:
        #rospy.set_param("/task_mode", "manual")
        #task = ManualTask(robot_manager)
        #print("manual tasks requested")
    #return task
        ManualTask()

class TaskGenerator:
    def __init__(self):
        #self.curr_goal_pos_ = None
        #self.task = get_predefined_task("")
        RandomTask()



if __name__ == '__main__':
    try:
      #  TaskGenerator()
    except rospy.ROSInterruptException:
        rospy.loginfo("Navigation finished.")

    